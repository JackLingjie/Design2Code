下面的代码依次会调用pre_process函数，和check_repetitive_content函数来处理html内容，之前的代码是传入html的路径进行处理，现在帮我直接传入html的内容进行处理
def visual_eval_v4_multi(input_item, debug=False):
    predict_html_list, original_html = input_list[0], input_list[1]
    predict_img_list = [html.replace(".html", ".png") for html in predict_html_list]
    predict_img_list = [input_item["image_path"]]
    # try:
    predict_blocks_list = []
    html_content = input_item["messages"][1]["content"]
    for predict_html in predict_html_list:
        predict_img = predict_html.replace(".html", ".png")
        # This will help fix some html syntax error
        pre_process(predict_html)
        try:  
            # 使用 subprocess.run 传递参数  
            result = subprocess.run(  
                ["python3", "screenshot_single_filter.py", "--content", html_content, "--png", "test.png"],  
                check=True,  
                text=True,  
                capture_output=True  
            )  
        except subprocess.CalledProcessError as e:  
            print(f"Command failed with error: {e.stderr}") 
        # os.system(f"python3 metrics/screenshot_single_filter.py --html {predict_html} --png {predict_img}")
        predict_blocks = get_blocks_ocr_free(predict_img)
        predict_blocks_list.append(predict_blocks)

def pre_process(html_file):
    check_repetitive_content(html_file)
    make_html(html_file)
    with open(html_file, 'r') as file:
        soup = BeautifulSoup(file, 'html.parser')
    soup_str = truncate_repeated_html_elements(soup)
    with open(html_file, 'w') as file:
        file.write(soup_str)

def check_repetitive_content(file_path, chunk_size=100, repetition_threshold=5, similarity_threshold=0.8, debug=False):
    """
    Checks for repetitive content in a text file, considering both exact and similar chunks, 
    ignoring HTML tags but keeping the original position reference.

    :param file_path: Path to the text file.
    :param chunk_size: The size of each chunk for comparison.
    :param repetition_threshold: Minimum number of repetitions to consider it as repetitive content.
    :param similarity_threshold: The threshold for considering two chunks as similar (0 to 1).
    :return: A tuple indicating if repetitive content was found and the position where it starts in the original file.
    """
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()

    # Clean HTML content and keep a map of positions
    content_no_html = re.sub('<.*?>', '', content)
    position_map = map_positions(content_no_html, content)

    # Split content into chunks
    chunks = [content_no_html[i:i + chunk_size] for i in range(0, len(content_no_html), chunk_size)]

    # Check for repetitive and similar chunks
    seen = {}
    repetitive_start = len(content_no_html)
    for i, chunk in enumerate(chunks):
        for seen_chunk, indexes in seen.items():
            similarity = difflib.SequenceMatcher(None, chunk, seen_chunk).ratio()
            if similarity >= similarity_threshold:
                indexes.append(i)
                if len(indexes) >= repetition_threshold:
                    clean_start = min(repetitive_start, indexes[0] * chunk_size)
                    c_repetitive_start = position_map[clean_start] if clean_start < len(position_map) else len(content)
                    if c_repetitive_start < repetitive_start:
                        repetitive_start = c_repetitive_start
                break
        else:
            seen[chunk] = [i]

    repetitive, start_position = repetitive_start != len(content_no_html), repetitive_start

    if repetitive:
        print(f"[Warning] Repetitive content found in {file_path}, start at {start_position}")
        print(f"[Warning] You might want to manually check whether the automatic repetition removal is correct.")
        if not debug:
            os.rename(file_path, file_path.replace(".html", "_old.txt"))
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(content[:start_position])
        else:
            with open(file_path.replace(".html", "_new.html"), 'w', encoding='utf-8') as file:
                file.write(content[:start_position])
